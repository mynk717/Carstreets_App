// app/api/admin/content/generate-calendar/route.ts - FIXED VERSION
import { NextRequest, NextResponse } from 'next/server';
import { AutoContentPipeline } from '@/lib/agents/autoContentPipeline';
import { prisma } from '@/lib/prisma';
import { verifyAdminAuth } from '@/lib/auth/admin';

export async function POST(request: NextRequest) {
  try {
    console.log('ðŸ—“ï¸ Generating automated content calendar...');
    
    // âœ… FIXED: Re-enable auth verification with better error handling
    const authResult = await verifyAdminAuth(request);
    if (!authResult.success) {
      console.log('âŒ Calendar generation - Authentication failed:', authResult.error);
      return NextResponse.json(
        { 
          success: false, 
          error: 'Unauthorized - admin access required',
          details: authResult.error 
        }, 
        { status: 401 }
      );
    }
    console.log('âœ… Calendar generation - Authentication successful');
    
    const { carIds } = await request.json();

    // âœ… FIXED: Better car selection with proper Prisma query
    let carsToProcess = [];
    if (carIds && Array.isArray(carIds)) {
      console.log(`ðŸ“‹ Using provided car IDs: ${carIds.length} cars`);
      carsToProcess = carIds;
    } else {
      console.log('ðŸ” No car IDs provided, selecting cars with images...');
      
      const carResults = await prisma.car.findMany({
        where: {
          images: {
            not: null
          }
        },
        select: { id: true, images: true, brand: true, model: true },
        take: 20,
        orderBy: { createdAt: 'desc' },
      });

      // Filter cars that have at least one image URL in images array
      const validCars = carResults.filter(car => 
        Array.isArray(car.images) && 
        car.images.length > 0 && 
        car.images.some(img => typeof img === 'string' && img.trim().length > 0)
      );

      carsToProcess = validCars
        .map(car => car.id)
        .slice(0, 10); // Limit to 10 cars for content generation
      
      console.log(`ðŸ“Š Found ${carResults.length} total cars, ${validCars.length} with valid images, selected ${carsToProcess.length} for processing`);
    }
    
    if (carsToProcess.length === 0) {
      console.log('âš ï¸ No cars available for content generation');
      return NextResponse.json({
        success: false,
        error: 'No cars with images found for content generation'
      }, { status: 400 });
    }
    
    // âœ… Generate automated content using your pipeline
    const pipeline = new AutoContentPipeline();
    
    console.log(`ðŸš€ Starting content generation for ${carsToProcess.length} cars...`);
    const readyContent = await pipeline.generateReadyToPostContent(carsToProcess);
    
    console.log(`ðŸ“ Generated ${readyContent.length} pieces of content`);
    
    // âœ… FIXED: Save generated content to database ContentCalendar table with better error handling
    const savedContent = [];
    let saveErrors = 0;
    
    for (const content of readyContent) {
      try {
        // âœ… FIXED: Only use fields that exist in the ContentCalendar schema
        const savedItem = await prisma.contentCalendar.create({
          data: {
            carId: content.carId,
            platform: content.platform,
            textContent: content.textContent,
            hashtags: content.hashtags,
            originalImage: content.originalImage,
            brandedImage: content.imageUrl,
            status: content.success ? 'draft' : 'failed',
            uniquenessScore: content.success ? 92 : 0,
            generationCost: content.cost || 0,
            autoGenerated: true,
            brandingApplied: content.success 
              ? ['CarStreets logo', 'Price overlay', 'Raipur location']
              : [],
            // âœ… REMOVED: generationError field doesn't exist in schema
            // Store error info in logs instead, or add to textContent if needed
          }
        });
        savedContent.push(savedItem);
        
        // âœ… Log errors separately for debugging
        if (!content.success && content.error) {
          console.error(`âŒ Content generation failed for car ${content.carId} on ${content.platform}:`, content.error);
        }
      } catch (saveError) {
        console.error('âŒ Failed to save content item:', {
          carId: content.carId,
          platform: content.platform,
          error: saveError
        });
        saveErrors++;
      }
    }

    const totalCost = readyContent.reduce((sum, item) => sum + (item.cost || 0), 0);
    const successfulContent = savedContent.filter(item => item.status === 'draft');

    console.log(`ðŸŽ‰ Content generation completed:`, {
      generated: readyContent.length,
      saved: savedContent.length,
      successful: successfulContent.length,
      errors: saveErrors,
      totalCost: totalCost.toFixed(4)
    });

    return NextResponse.json({
      success: true,
      generated: successfulContent.length,
      content: savedContent,
      totalCost,
      statistics: {
        total_generated: readyContent.length,
        saved_to_db: savedContent.length,
        successful_items: successfulContent.length,
        failed_items: readyContent.length - successfulContent.length,
        save_errors: saveErrors
      }
    });
    
  } catch (error) {
    console.error('ðŸ’¥ Content calendar generation failed:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : String(error),
      details: 'Check server logs for more information'
    }, { status: 500 });
  }
}