// app/api/dealers/[subdomain]/content/generate-calendar/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/api/auth/[...nextauth]/route";
import { AutoContentPipeline } from '@/lib/agents/autoContentPipeline';
import { prisma } from '@/lib/prisma';

// Helper: Extract subdomain from request URL
function extractSubdomain(request: NextRequest) {
  const pathParts = request.nextUrl.pathname.split("/");
  return pathParts[pathParts.indexOf("dealers") + 1];
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const subdomain = extractSubdomain(request);

    // Only use schema fields!
    const dealer = await prisma.dealer.findUnique({
      where: { subdomain }
    });
    if (!dealer) {
      return NextResponse.json({ error: "Forbidden: Not your dealer" }, { status: 403 });
    }

    const { carIds } = await request.json();

    // Car selection logic
    let carsToProcess: string[] = [];
    if (carIds && Array.isArray(carIds)) {
      carsToProcess = carIds;
    } else {
      const carResults = await prisma.car.findMany({
        where: { dealerId: dealer.id, images: { not: null } },
        select: { id: true, images: true, brand: true, model: true },
        take: 10,
        orderBy: { createdAt: 'desc' },
      });
      const validCars = carResults.filter(car =>
        Array.isArray(car.images) &&
        car.images.length > 0 &&
        car.images.some(img => typeof img === 'string' && img.trim().length > 0)
      );
      carsToProcess = validCars.map(car => car.id);
    }

    if (carsToProcess.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'No cars with images found for content generation'
      }, { status: 400 });
    }

    // Content generation
    const pipeline = new AutoContentPipeline();
    const readyContent = await pipeline.generateReadyToPostContent(carsToProcess);

    // Save generated content to DB
    const savedContent = [];
    let saveErrors = 0;
    for (const content of readyContent) {
      try {
        const savedItem = await prisma.contentCalendar.create({
          data: { 
            dealerId: dealer.id,
            carId: content.carId,
            platform: content.platform,
            textContent: content.textContent,
            hashtags: content.hashtags,
            originalImage: content.originalImage,
            brandedImage: content.imageUrl,
            status: content.success ? 'draft' : 'failed',
            uniquenessScore: content.success ? 92 : 0,
            generationCost: content.cost || 0,
            autoGenerated: true,
            brandingApplied: content.success ? ['CarStreets logo', 'Price overlay', 'Raipur location'] : [],
          }
        });
        savedContent.push(savedItem);
      } catch (saveError) {
        console.error('âŒ Failed to save content item:', {
          carId: content.carId,
          platform: content.platform,
          error: saveError
        });
        saveErrors++;
      }
    }

    const totalCost = readyContent.reduce((sum, item) => sum + (item.cost || 0), 0);
    const successfulContent = savedContent.filter(item => item.status === 'draft');

    return NextResponse.json({
      success: true,
      generated: successfulContent.length,
      content: savedContent,
      totalCost,
      statistics: {
        total_generated: readyContent.length,
        saved_to_db: savedContent.length,
        successful_items: successfulContent.length,
        failed_items: readyContent.length - successfulContent.length,
        save_errors: saveErrors
      }
    });

  } catch (error) {
    console.error('ðŸ’¥ Content calendar generation failed:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : String(error),
      details: 'Check server logs for more information'
    }, { status: 500 });
  }
}
