// app/api/dealers/[subdomain]/content/generate-calendar/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/api/auth/[...nextauth]/route";
import { AutoContentPipeline } from '@/lib/agents/autoContentPipeline';
import { prisma } from '@/lib/prisma';

// Helper: Extract subdomain from request URL
function extractSubdomain(request: NextRequest) {
  const pathParts = request.nextUrl.pathname.split("/");
  return pathParts[pathParts.indexOf("dealers") + 1];
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const subdomain = extractSubdomain(request);

    // âœ… Fetch dealer with full context
    const dealer = await prisma.dealer.findUnique({
      where: { subdomain },
      select: {
        id: true,
        businessName: true,
        location: true,
        logo: true,
        description: true,
        phoneNumber: true,
        email: true,
      }
    });

    if (!dealer) {
      return NextResponse.json({ error: "Dealer not found" }, { status: 404 });
    }

    // âœ… Verify session user matches dealer
    if (session.user.id !== dealer.id) {
      return NextResponse.json({ error: "Forbidden: Not your dealer" }, { status: 403 });
    }

    // âœ… Check for existing drafts (prevent spam)
    const existingDrafts = await prisma.contentCalendar.count({
      where: {
        dealerId: dealer.id,
        status: 'draft',
        createdAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
        }
      }
    });

    if (existingDrafts > 20) {
      return NextResponse.json({
        success: false,
        error: `You have ${existingDrafts} pending draft posts. Please approve or delete some before generating more content.`
      }, { status: 400 });
    }

    // âœ… Parse request body
    const body = await request.json();
    const { carIds, platforms, carCount } = body;

    // Car selection logic
    let carsToProcess: string[] = [];
    if (carIds && Array.isArray(carIds)) {
      carsToProcess = carIds;
    } else {
      const carResults = await prisma.car.findMany({
        where: { 
          dealerId: dealer.id, 
          images: { not: null },
          carStreetsListed: true
        },
        select: { id: true, images: true, brand: true, model: true },
        take: carCount || 10,
        orderBy: { createdAt: 'desc' },
      });

      const validCars = carResults.filter(car =>
        Array.isArray(car.images) &&
        car.images.length > 0 &&
        car.images.some(img => typeof img === 'string' && img.trim().length > 0)
      );

      carsToProcess = validCars.map(car => car.id).slice(0, carCount || 10);
    }

    if (carsToProcess.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'No cars with images found for content generation'
      }, { status: 400 });
    }

    console.log(`ðŸš€ Generating content for ${carsToProcess.length} cars`);

    // âœ… Content generation with dealer context
    const pipeline = new AutoContentPipeline();
    const readyContent = await pipeline.generateReadyToPostContent(
      carsToProcess,
      platforms || ['instagram', 'facebook'],
      {
        id: dealer.id,
        businessName: dealer.businessName,
        location: dealer.location || 'India',
        logo: dealer.logo,
        description: dealer.description,
        phoneNumber: dealer.phoneNumber,
        email: dealer.email,
      }
    );

    console.log(`âœ… Generated ${readyContent.length} content items`);

    // âœ… Save generated content to DB
    const savedContent = [];
    let saveErrors = 0;

    for (const content of readyContent) {
      try {
        const savedItem = await prisma.contentCalendar.create({
          data: { 
            dealerId: dealer.id,
            carId: content.carId,
            platform: content.platform,
            textContent: content.textContent,
            // âœ… Convert hashtag array to array (already correct)
            hashtags: content.hashtags,
            originalImage: content.originalImage,
            brandedImage: content.imageUrl,
            status: content.success ? 'draft' : 'failed',
            uniquenessScore: content.success ? 92 : 0,
            generationCost: content.cost || 0,
            autoGenerated: true,
            brandingApplied: content.success 
              ? [
                  `${dealer.businessName} branding`, 
                  'AI scene transformation',
                  `${dealer.location} context`
                ] 
              : [],
          }
        });
        savedContent.push(savedItem);
      } catch (saveError) {
        console.error('âŒ Failed to save content item:', {
          carId: content.carId,
          platform: content.platform,
          error: saveError
        });
        saveErrors++;
      }
    }

    const totalCost = readyContent.reduce((sum, item) => sum + (item.cost || 0), 0);
    const successfulContent = savedContent.filter(item => item.status === 'draft');

    console.log(`ðŸ’¾ Saved ${successfulContent.length}/${readyContent.length} items to database`);

    return NextResponse.json({
      success: true,
      generated: successfulContent.length,
      content: savedContent,
      totalCost: Number(totalCost.toFixed(2)),
      statistics: {
        total_generated: readyContent.length,
        saved_to_db: savedContent.length,
        successful_items: successfulContent.length,
        failed_items: readyContent.length - successfulContent.length,
        save_errors: saveErrors,
        platforms_used: platforms || ['instagram', 'facebook']
      }
    });

  } catch (error) {
    console.error('ðŸ’¥ Content calendar generation failed:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : String(error),
      details: 'Check server logs for more information',
      stack: process.env.NODE_ENV === 'development' ? (error as Error).stack : undefined
    }, { status: 500 });
  }
}
